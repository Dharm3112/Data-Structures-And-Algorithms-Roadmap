# üó∫Ô∏è Data Structures & Algorithms Roadmap

This roadmap is designed to take you from the basics of programming to advanced interview preparation, covering essential data structures, algorithms, and problem-solving techniques.

---

## üèÅ Phase 1: The Prerequisites
Before diving into DSA, ensure you are comfortable with the syntax and basics of one coding language.

- [ ] **Choose a Programming Language** (Python, Java, C++, JavaScript, etc.)
- [ ] Understand Variables, Loops, and Conditions
- [ ] Understand Functions and Classes

---

## üèóÔ∏è Phase 2: Data Structures (The Building Blocks)
Learn how data is stored and organized.

### 2.1 Linear Data Structures
Sequential organization of data.
- [ ] **Arrays** (Static & Dynamic)
- [ ] **Linked Lists** (Singly, Doubly, Circular)
- [ ] **Stacks** (LIFO principle)
- [ ] **Queues** (FIFO principle)

### 2.2 Non-Linear Data Structures
Hierarchical or interconnected organization of data.
- [ ] **Trees** (Binary Trees, BST, Heaps)
- [ ] **Graphs** (Directed, Undirected, Weighted)

### 2.3 CRUD Operations
Master the basic operations for all the structures above.
- [ ] **C**reate (Insert data)
- [ ] **R**ead (Retrieve data)
- [ ] **U**pdate (Modify data)
- [ ] **D**elete (Remove data)

---

## üîç Phase 3: Traversal & Searching
How to navigate through your data structures.

### 3.1 Searching Algorithms
- [ ] **Linear Search** (Simple iteration)
- [ ] **Binary Search** (Divide and conquer - for sorted data)
- [ ] **Depth First Search (DFS)** (Stack-based graph/tree traversal)
- [ ] **Breadth First Search (BFS)** (Queue-based graph/tree traversal)

### 3.2 Traversal Techniques
- [ ] **In-order Traversal** (Left, Root, Right)
- [ ] **Pre-order Traversal** (Root, Left, Right)
- [ ] **Post-order Traversal** (Left, Right, Root)
- [ ] **Level-order Traversal**

---

## üî¢ Phase 4: Sorting Algorithms
Techniques to rearrange data in a specific order.

**Basic & Educational**
- [ ] **Bubble Sort** (Simple, pairwise swapping)
- [ ] **Selection Sort** (Finds minimum, places at start)
- [ ] **Insertion Sort** (Builds sorted list one-by-one)
- [ ] **Cycle Sort** (Minimizes memory writes)

**Efficient ($O(N \log N)$)**
- [ ] **Merge Sort** (Divide and conquer, stable)
- [ ] **Quick Sort** (Pivot-based partitioning)
- [ ] **Heap Sort** (Uses binary heap data structure)
- [ ] **Shell Sort** (Generalized insertion sort)

**Non-Comparison / Linear ($O(N)$)**
- [ ] **Counting Sort** (Integer sorting based on keys)
- [ ] **Radix Sort** (Sorts digit by digit)
- [ ] **Bucket Sort** (Distributes elements into buckets)

**Hybrid (Real-World Defaults)**
- [ ] **TimSort** (Merge & Insertion hybrid - Python/Java default)
- [ ] **IntroSort** (Quick, Heap & Insertion hybrid - C++ default)
---

## üß† Phase 5: Core Algorithmic Concepts
Foundational concepts for solving complex problems.

- [ ] **Recursion** (Functions calling themselves)
- [ ] **Backtracking** (Solving incrementally, removing failed solutions)
- [ ] **Dynamic Programming (DP)** (Breaking problems into sub-problems)

---

## ‚ö° Phase 6: Optimization Techniques (Problem Solving Patterns)
These are specific patterns frequently asked in coding interviews to optimize solutions.

- [ ] **Two Pointers** (Iterating with two references)
- [ ] **Sliding Window** (Sub-array/substring problems)
- [ ] **Prefix / Suffix Sums** (Pre-computation for range queries)

---

## üíº Phase 7: Interview Preparation
Bringing it all together.

- [ ] Solve problems on LeetCode / HackerRank / CodeForces
- [ ] Practice Time Complexity Analysis (Big O Notation)
- [ ] Practice Space Complexity Analysis
- [ ] Mock Interviews
